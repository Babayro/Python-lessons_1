print('БЕСКОНЕЧНЫЕ ГЕНЕРАТОРЫ, РЕЗУЛЬТАТ РАБОТЫ ПРОГРАММЫ')

# БЕСКОНЕЧНЫЙ ПРОЦЕСС

# ЗАДАЧА. ТКАЦКИЙ СТАНОК ВОСПРОИЗВОДИТ 4 УЗОРА ОПРЕДЕЛЁННОЕ КОЛИЧЕСТВО РАЗ
def create_patterns():

                                        # БЛОК С ВХОДЯЩИМИ ДАННЫМИ
 # ПЕРЕМЕННАЯ С КОЛИЧЕСТВОМ УЗОРОВ (ЭЛЕМЕНТОВ СПИСКА)
    max_patterns_number = 7
    patterns = ('First pattern', 'Second pattern', 'Third pattern', 'Forth pattern')
# СЧЁТЧИК СТАРТА
    i = 0
# ПЕРЕМЕННАЯ НОВЫЙ ЛИСТ КУДА ВЫВОДИМ КОЛИЧЕСТВО УЗОРОВ
    result_list = []
                                        # БЛОК ОБРАБОТКИ ВХОДЯЩИХ ДАННЫХ
 # ПРОВЕРКА УСЛОВИЯ ЕСЛИ КОЛИЧЕСТВО ЭЛЕМЕНТОВ МЕНЬШЕ МАКСИМАЛЬНО ЗАЯВЛЕННОГО КОЛИЧЕСТВА УЗОРОВ ТО
    while len(result_list) < max_patterns_number:
# i БОЛЬШЕ ИЛИ РАВНО КОЛИЧЕСТВУ ЭЛЕМЕНТОВ СПИСКА
        if i >= len(patterns):
# !!!СТАВИМ СЧЁТЧИК НА СТАРТ, И ЕСЛИ СЧЁТЧИК БОЛЬШЕ ИЛИ РАВНО ДЛЯНЫ СПИСКА ТО ОБНУЛЯЕМ ЕГО, ТАКИМ ОБРАЗОМ ПРИРЫВАЯ ЦИКЛ!!!
            i = 0
# ДОБАВЛЯЕМ В СПИСОК
        result_list.append(patterns[i])
        i += 1
# ВОЗВРАЩАЕМ СПИСОК
    return result_list
print(create_patterns())

# БЫВАЮТ СИТУАЦИИ КОГДА НУЖНО ВЫВЕСТИ ОЧЕНЬ БОЛЬШОЙ СПИСОК, ЧТО В СВОЮ ОЧЕРЕДЬ ЗАНИМАЕТ МНОГО ПАМЯТИ
# НА ПРИМЕРЕ С УЗОРАМИ ЕА МНЕ ОБЯЗАТЕЛЬНО ВЫВОДИТЬ ВСЕ УЗОРЫ ПО ПОРЯДКУ,Т.К. ОНИ ОДИНАКОВЫЕ
# НАМ НУЖЕН ОДИН УЗОР, ПО ФАКТУ ПЕРВЫЙ, В ОДИН МОМЕНТ ВРЕМЕНИ
# ДЛЯ ТАКОЙ ЗАДАЧИ НАМ И ПОТРЕБУЕТСЯ ГЕНЕРАТОР

                        # БЛОК С ВХОДНЫМИ ДАННЫМИ
def create_patterns_2():
    patterns_2 = ('First pattern', 'Second pattern', 'Third pattern', 'Forth pattern')

    i_2 = 0
                        # БЛОК ОБРАБОТКИ ВХОДНЫХ ДАННЫХ
    while True:
        if i_2 >= len(patterns_2):
            i_2 = 0
# ФУНКЦИЯ yield ВЫРАБАТЫВАЕТ ЗНАЧЕНИЯ И НЕ ОБНУЛЯЕТСЯ ПОСЛЕ ИТЕРАЦИИ, ТАКЖЕ КАК И next ЗАСЫПАЕТ ПОСЛЕ ПЕРВОЙ И ПОСЛЕДУЮЩИХ ИТЕРАЦИЙ
# ПРИ ЗАСЫПАНИИ ОНА ЗАПОМИНАЕТ ПОСЛЕДНЕЕ ЗНАЧЕНИЕ, И ДАЛЕЕ РАБОТА БУДЕТ НАЧАТА НЕ С 0, А С ЗАПОМНИННОГО СОСТОЯНИЯ
        yield patterns_2[i_2]
        i_2 += 1
current_pattern_2 = create_patterns_2()
print(current_pattern_2.__next__())
print(current_pattern_2.__next__())
print(current_pattern_2.__next__())
print(current_pattern_2.__next__())
print(current_pattern_2.__next__())

# ДАННЫЙ СПОСОБ СОЗДНАНИЯ ГЕНЕРАТОРА ПРИМЕНЯТСЯ ЕСЛИ НАМ НУЖНО БЕСКОНЕЧНО И ПОСЛЕДОВАТЕЛЬНО ОБРАЩАТЬСЯ К ЭЛЕМЕНТАМ ПОСЛЕДОВАТЕЛЬНОСТИ
# ТАКОЕ ОБРАЩЕНИЕ УДОБНО, Т.К. НЕ ЗАСОРЯЕТСЯ ПАМЯТЬ КОМПЬЮТЕРА, Т.К. МЫ НЕ ЗАГРУЖАЕМ ВСЮ ПОСЛЕДОВАТЕЛЬНОСТЬ

                               # ЗАДАЧА
def get_infinite_square_generator():
    number = 1
    while True:
        yield number * number
        number += 1
yyyy = get_infinite_square_generator()
print(yyyy.__next__())
print(yyyy.__next__())
print(yyyy.__next__())
print(yyyy.__next__())